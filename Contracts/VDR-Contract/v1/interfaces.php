<?php
/* based on ORSCF VisitData Contract v1.9.1.11852 */

include 'models.php';

public interface IVdrApiInfoService {
  
  /*
  * returns the version of the ORSCF specification which is implemented by this API, (this can be used for backward compatibility within inhomogeneous infrastructures)
  */
  function GetApiVersion(): string;
  
  /*
  * returns a list of API-features (there are several 'services' for different use cases, described by ORSCF) supported by this implementation. The following values are possible: 'VdrEventSubscription', 'VisitConsume', 'VisitSubmission', 'VisitHL7Export', 'VisitHL7Import', 'DataRecordingSubmission'
  */
  function GetCapabilities(): array;
  
  /*
  * returns a list of available capabilities ("API:VisitDataConsume") and/or data-scopes ("Study:9B2C3F48-2941-2F8F-4D35-7D117D5C6F72") which are permitted for the CURRENT ACCESSOR and gives information about its 'authState', which can be: 0=auth needed / 1=authenticated / -1=auth expired / -2=auth invalid/disabled
  *
  * @param $authState
  */
  function GetPermittedAuthScopes(int &$authState): array;
  
  /*
  * OPTIONAL: If the authentication on the current service is mapped using tokens and should provide information about the source at this point, the login URL to be called up via browser (OAuth <see href="https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html">'CIBA-Flow'</see>) is returned here.
  */
  function GetOAuthTokenRequestUrl(): string;
  
}

public interface IVdrEventSubscriptionService {
  
  /*
  * Creates a subscription for changes which are affecting Visits. On success, a 'SubscriptionUid' will be returned and a call will be made to the given subscriberUrl + '/ConfirmAsSubscriber'. After the subscription has been confirmed, the requested events will be pushed to subscriberUrl + '/NoticeChangedVisits' (NOTICE: the receiving methods also are documented here, because this service itself can act as subscriber)
  *
  * @param $subscriberUrl the root-url of the subscriber which needs to provide at least the methods
   '/ConfirmAsSubscriber' and '/NoticeChangedVisits'
  * @param $filter if provided, the subscription will only publish events for
   records matching to the given filter
  */
  function SubscribeForChangedVisits(string $subscriberUrl, VisitFilter $filter): string;
  
  /*
  * Receives notifications about changes which are affecting Visits. IMPORTANT: this method is dedicated to the usecase, when this service itself acts as a subscriber! So this can be called by an foreign service during the setup of a subscription, which was previously requested from here. The opposite case: any client subscribing to events from here, must provide its own http endpoint that has such a method!
  *
  * @param $eventUid a UUID which identifies the current event message
  * @param $eventSignature a SHA256 Hash of SubscriptionSecret + EventUid
   (in lower string representation, without '-' characters!)
   Sample: SHA256('ThEs3Cr3T'+'c997dfb1c445fea84afe995307713b59')
   = 'a320ef5b0f563e8dcb16d759961739977afc98b90628d9dc3be519fb20701490'
  * @param $subscriptionUid a UUID which identifies the subscription for which this event is published
  * @param $publisherUrl root-URL of the VDR-Service which is publishing this event
  * @param $createdRecords
  * @param $modifiedRecords
  * @param $archivedRecords
  * @param $terminateSubscription an array, which contains one element per changed visit
  */
  function NoticeChangedVisits(string $eventUid, string $eventSignature, string $subscriptionUid, string $publisherUrl, array $createdRecords, array $modifiedRecords, array $archivedRecords, bool &$terminateSubscription);
  
  /*
  * Confirms a Subscription. IMPORTANT: this method is dedicated to the usecase, when this service itself acts as a subscriber! So this can be called by an foreign service during the setup of a subscription, which was previously requested from here. The opposite case: any client subscribing to events from here, must provide its own http endpoint that has such a method!
  *
  * @param $publisherUrl root-URL of the VDR-Service on which the subscription was requested
  * @param $subscriptionUid the Uid of the subscription which should be confirmed
  * @param $secret A secret which is generated by the subscriber and used to provide additional security.
   It will be required for the 'TerminateSubscription' method and it is used to generate
   SHA256 hashes for signing the delivered event messages.
   The secret should: have a minimum length of 32 characters.
   A null or empty string has the semantics that the subscriber refuses to confirm
   and cancels the subscription setup.
  */
  function ConfirmAsSubscriber(string $publisherUrl, string $subscriptionUid, string &$secret);
  
  /*
  * Terminates a subscription (on publisher side) and returns a boolean, which indicates success.
  *
  * @param $subscriptionUid the Uid of the subscription which should be terminated
  * @param $secret the (same) secret, which was given by the subscriber during the subscription setup
  */
  function TerminateSubscription(string $subscriptionUid, string $secret): bool;
  
  /*
  * Returns an array of subscriptionUid's. This method helps subscribers to evaluate whether current subscriptions are still active.
  *
  * @param $subscriberUrl
  * @param $secret the (same) secret, which was given by the subscriber during the subscription setup
  */
  function GetSubsriptionsBySubscriberUrl(string $subscriberUrl, string $secret): array;
  
}

public interface IDataEnrollmentService {
  
  /*
  * Enrolls recorded data to be stored as 'DataRecording'-Record related to a explicitly addressed Visit inside of this repository. This goes ahead with an validation process for each enrollment, therefore a dataEnrollmentUid will be returned which can be used to query the state of this process via 'GetValidationState'.
  *
  * @param $targetvisitUid the ORSCF-Visit-UID to address the parent visit for which the given data should be submitted
  * @param $taskExecutionTitle title of the task execution as defined in the 'StudyWorkflowDefinition' (originated from the sponsor)
  * @param $executionDateTimeUtc the time, when the data was recorded
  * @param $dataSchemaKind 'FhirQuestionaire' / 'XML' / 'CSV' / 'Custom'
  * @param $dataSchemaUrl the schema-url of the data which were stored inside of the 'RecordedData' field
  * @param $dataSchemaVersion version of schema, which is addressed by the 'DataSchemaUrl'
  * @param $dataLanguage Language of free-text information inside of the data content
  * @param $recordedData RAW data, in the schema as defined at the 'DataSchemaUrl'
  */
  function EnrollDataForVisitExplicit(string $targetvisitUid, string $taskExecutionTitle, string $executionDateTimeUtc, string $dataSchemaKind, string $dataSchemaUrl, string $dataSchemaVersion, string $dataLanguage, string $recordedData): string;
  
  /*
  * Enrolls recorded data to be stored as 'DataRecording'-Record related to a visit inside of this repository (which is implicitely resolved using the given 'visitExecutionTitle' and 'subjectIdentifier') . This goes ahead with an validation process for each enrollment, therefore a dataEnrollmentUid will be returned which can be used to query the state of this process via 'GetValidationState'.
  *
  * @param $studyUid the ORSCF-Study-UID which is used to lookup for the target visit for which the given data should be submitted
  * @param $subjectIdentifier the study related identity of the patient (usually a pseudonym) which is used to lookup for the target visit for which the given data should be submitted
  * @param $visitExecutionTitle unique title of the visit execution as defined in the 'StudyWorkflowDefinition' which is used to lookup for the target visit for which the given data should be submitted
  * @param $taskExecutionTitle title of the task execution as defined in the 'StudyWorkflowDefinition' (originated from the sponsor)
  * @param $executionDateTimeUtc the time, when the data was recorded
  * @param $dataSchemaKind 'FhirQuestionaire' / 'XML' / 'CSV' / 'Custom'
  * @param $dataSchemaUrl the schema-url of the data which were stored inside of the 'RecordedData' field
  * @param $dataSchemaVersion version of schema, which is addressed by the 'DataSchemaUrl'
  * @param $dataLanguage Language of free-text information inside of the data content
  * @param $recordedData RAW data, in the schema as defined at the 'DataSchemaUrl'
  */
  function EnrollDataForVisitImplicit(string $studyUid, string $subjectIdentifier, string $visitExecutionTitle, string $taskExecutionTitle, string $executionDateTimeUtc, string $dataSchemaKind, string $dataSchemaUrl, string $dataSchemaVersion, string $dataLanguage, string $recordedData): string;
  
  /*
  * Providing the current validation state for a given data enrollment process
  *
  * @param $dataEnrollmentUid
  */
  function GetValidationState(string $dataEnrollmentUid): DataEnrollmentValidationState;
  
}

public interface IDataRecordingSubmissionService {
  
  /*
  * ImportDataRecordings
  *
  * @param $dataRecordings
  * @param $createdDataRecordingUids
  * @param $updatedDataRecordingUids
  */
  function ImportDataRecordings(array $dataRecordings, array &$createdDataRecordingUids, array &$updatedDataRecordingUids);
  
}

public interface IVisitConsumeService {
  
  /*
  * Searches Visits by a given 'filter' (if provided), sorts the results by the given 'sortingField' (if provided) and returns an array of VisitUids for the matching records.
  *
  * @param $result
  * @param $sortingField A fieldname, which should be used to sort the result (can also be a 'CustomField').
   If not provided, the result will be sorted by the creation date of the records
  * @param $sortDescending toggles the sorting direction
  * @param $filter values by field name (can also be a 'CustomField') which will used as AND-linked filter
  * @param $includeArchivedRecords includes archived records in the result
  * @param $limitResults a value greather than zero will represent a maximum count of results, that sould be returned
  */
  function SearchVisits(array &$result, string $sortingField, bool $sortDescending, VisitFilter $filter, bool $includeArchivedRecords, int $limitResults);
  
  /*
  * Searches Visits which have been modified after(or at) the given 'minTimestampUtc', matching to the given 'filter' (if provided). The result is sorted descenting by the timestamp of the modification (latest first) and will include archived records.
  *
  * @param $minTimestampUtc start of the timespan to search (as UNIX-Timestamp)
  * @param $latestTimestampUtc the exact timestamp of the search (as UNIX-Timestamp)
  * @param $createdRecords
  * @param $modifiedRecords
  * @param $archivedRecords
  * @param $filter values by field name (can also be a 'CustomField') which will used as AND-linked filter
  */
  function SearchChangedVisits(int $minTimestampUtc, int &$latestTimestampUtc, array &$createdRecords, array &$modifiedRecords, array &$archivedRecords, VisitFilter $filter);
  
  /*
  * GetCustomFieldDescriptorsForVisit
  *
  * @param $languagePref Preferred language for the 'DisplayLabel' and 'InputDescription'
   fields of the returned descriptors. The default is 'EN'.
  */
  function GetCustomFieldDescriptorsForVisit(string $languagePref): array;
  
  /*
  * Checks the existence of 'Visits' for a given list of visitUids
  *
  * @param $visitUids
  * @param $unavailableVisitUids
  * @param $availableVisitUids
  */
  function CheckVisitExisitence(array $visitUids, array &$unavailableVisitUids, array &$availableVisitUids);
  
  /*
  * loads the requested visits and returns lightweight json objects (without childs), which are optimized to be displayed as table (the most common UI use case). This models containig a combination of: essential fieds from the record, calculated fields (numbers of child records), custom fields (choosen by the service)
  *
  * @param $visitUids
  * @param $unavailableVisitUids
  * @param $result
  */
  function GetVisitFields(array $visitUids, array &$unavailableVisitUids, array &$result);
  
  /*
  * exports full 'VisitStructures'
  *
  * @param $visitUids
  * @param $unavailableVisitUids
  * @param $result
  */
  function ExportVisits(array $visitUids, array &$unavailableVisitUids, array &$result);
  
}

public interface IVisitHL7ExportService {
  
  /*
  * Exports a structure containing HL7/FHIR-Ressources (JSON only) and the essential fields which are required to qualify a ORSCF record.
  *
  * @param $visitUid
  * @param $visitFhirRessources
  */
  function ExportVisitFhirRessources(string $visitUid, array &$visitFhirRessources): bool;
  
}

public interface IVisitHL7ImportService {
  
  /*
  * Exports a structure containing HL7/FHIR-Ressources (JSON only) and the essential fields which are required to qualify a ORSCF record.
  *
  * @param $visitFhirRessources
  * @param $createdVisitUids
  * @param $updatedVisitUids
  */
  function ImportVisitFhirRessources(array $visitFhirRessources, array &$createdVisitUids, array &$updatedVisitUids);
  
}

public interface IVisitSubmissionService {
  
  /*
  * ArchiveVisits
  *
  * @param $visitUids
  * @param $archivedVisitUids also including the Uids of already archived records
  */
  function ArchiveVisits(array $visitUids, array &$archivedVisitUids);
  
  /*
  * UnarchiveVisits
  *
  * @param $visitUids
  * @param $unarchivedVisitUids
  */
  function UnarchiveVisits(array $visitUids, array &$unarchivedVisitUids);
  
  /*
  * ApplyVisitMutations
  *
  * @param $mutationsByVisitUid
  * @param $updatedVisitUids
  */
  function ApplyVisitMutations(object $mutationsByVisitUid, array &$updatedVisitUids);
  
  /*
  * ApplyVisitBatchMutation
  *
  * @param $visitUids
  * @param $mutation
  * @param $updatedVisitUids
  */
  function ApplyVisitBatchMutation(array $visitUids, BatchableVisitMutation $mutation, array &$updatedVisitUids);
  
  /*
  * ImportVisits
  *
  * @param $visits
  * @param $createdVisitUids
  * @param $updatedVisitUids
  */
  function ImportVisits(array $visits, array &$createdVisitUids, array &$updatedVisitUids);
  
}
